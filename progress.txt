## Reminder

**Examples of good progress.txt additions:**
- "When modifying X, also update Y to keep them in sync"
- "This module uses pattern Z for all API calls"
- "Tests require the dev server running on PORT 3000"
- "Field names must match the template exactly"

**Do NOT add:**
- Story-specific implementation details
- Temporary debugging notes
- Information already in progress.txt

---
## Codebase Patterns
- Kafka client functions in `kafka_client.py` catch all exceptions internally, log warnings, return empty/zero values — never raise
- Module imports inside functions (e.g., `from kafka_client import get_committed_offsets` inside `_process_group`) require patching at the source module, not the calling module
- Use `uv pip` instead of `pip`, `uv run python` instead of `python`
- SQLite PRAGMA `auto_vacuum=INCREMENTAL` must be set BEFORE creating tables and requires a `commit()` to take effect
- Each worker thread (Sampler, Reporter, Housekeeping, StateManager) should receive `db_path` string and create its own connection via `database.get_connection(db_path)` - never share a connection across threads
- Tests that use StateManager/Reporter/Housekeeping need initialized database; use `db_path_initialized` fixture from conftest.py
- When calling `get_committed_offsets` from kafka_client, convert Set to List since the function expects List[Tuple[str, int]]

---
## Learnings
Kafka / Distributed Systems

When a function creates a resource that's needed later, return it for reuse rather than creating another instance
The describe_consumer_groups call already provides per-group partition data — don't discard it
Idle group detection relies on per-group partition assignments; groups with no active assignments properly return empty partition sets

Testing / Patching

When patching function imports inside methods, patch at the source module (e.g. kafka_client.get_committed_offsets) not the calling module
Tests that create workers (StateManager, Reporter, Housekeeping) need an initialized database — use a db_path_initialized fixture
Fix test fixtures to use db_path instead of passing connections directly

SQLite

PRAGMA auto_vacuum must be set BEFORE creating tables and requires an explicit commit
PRAGMA statements don't support bound parameters — validate input first, then use an f-string
When you only need one value from a table, write a purpose-built query rather than fetching all rows and extracting one

Worker / Threading Patterns

SQLite connections should be per-thread — pass db_path and let each worker create its own connection
For timed worker loops: capture cycle_start, run work, calculate elapsed, subtract from interval, sleep max(0, remainder) — prevents back-to-back cycles when work exceeds the interval

State / Business Logic

New groups start with consecutive_static=0 and will report ONLINE for threshold cycles before being detectable as OFFLINE — this is a known startup blind spot, not a bug
Groups with DB history are identified by presence in the consumer_commits table
When marking idle groups as OFFLINE, iterate over all previously tracked topics for that group
RECOVERING groups are actively consuming, so they warrant "fine" resolution — only OFFLINE should produce "coarse" resolution

- **Learnings for future iterations:**
  - When removing auto-commit from insert functions, all callers (tests and code) need to explicitly call commit_batch
  - Tests using worker threads need to use the worker's connection (e.g., s._db_conn) not the fixture connection for queries after operations
  - WAL mode should allow visibility across connections, but explicit commit is still needed for durability
- **Learnings for future iterations:**
  - SQLite connections cannot be shared across threads - need separate lock for connection access
  - Use two locks: one for in-memory state (RLock for re-entrant), one for DB connection (Lock for serialization)
  - In-memory state update is fast (dict operation), DB write is slow (I/O) - keep them separate under different locks
  - The persistent connection pattern eliminates 100+ connection open/close operations and 200+ PRAGMA commits per cycle
  - StateManager is called only from sampler thread in production, but tests validate thread-safety for robustness
- **Learnings for future iterations:**
  - When fixing state machine bugs, tests may be testing buggy behavior - need to update tests to reflect correct behavior
  - Added get_all_groups_with_history() function to database.py for finding idle groups with history
  - The state machine is conservative: requires positive evidence of advancement, not absence of evidence of stasis

---
## Progress updates

## 2026-02-23 - Idle Group Log Storm Fix + Ghost Group Retirement
- What was implemented:
  - Fixed log storm issue where `_handle_idle_group` was logging WARNING and writing DB every cycle for already-OFFLINE groups
  - Added ghost group retirement: groups completely absent from Kafka are automatically removed after a configurable retention period
  - Added `absent_group_retention_seconds` config field (optional, defaults to 604800 = 7 days)
  - Added `delete_group_data()` function to database.py for removing group data
  - Added `remove_group()` method to StateManager for clearing in-memory state
  - Rewrote `_handle_idle_group()` to check current status before acting (transition-only, no repeat writes)
  - Added `_retire_ghost_groups()` method to Sampler for automatic cleanup

- Files changed:
  - src/config.py (added config field and loading)
  - src/database.py (added delete_group_data function)
  - src/state_manager.py (added remove_group method)
  - src/sampler.py (rewrote _handle_idle_group, added _retire_ghost_groups, wired into run loop)
  - config.yaml and test_config.yaml (added new config setting)
  - src/tests/test_config.py (added 2 tests for new config field)
  - src/tests/test_database.py (added 3 tests for delete_group_data)
  - src/tests/test_state_manager.py (added 4 tests for remove_group)
  - docs/01-configuration-spec.md (documented new config field)
  - docs/02-database-design.md (documented new database functions)
  - docs/04-state-manager.md (documented remove_group method)
  - docs/10-idle-group-handling.md (new comprehensive documentation)

- **Learnings for future iterations:**
  - Idle group handling should check current status before acting to avoid redundant logs/writes
  - Groups in Kafka but with no active members (Empty state) should not be retired - only groups completely absent from Kafka
  - When adding new config fields with defaults, make them optional in load_config with required=False
  - Ghost group retirement runs AFTER idle group transition in the same cycle to avoid race conditions
  - State transitions should be logged once at transition time, not every cycle
  - The sampler's batch transaction includes group status updates, idle handling, and retirement - all committed atomically
---
